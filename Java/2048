
import java.lang.reflect.Array;
import java.util.Arrays;

import java.util.Random;

import java.util.Scanner;

public class Project {

	/* VARIABLES */

	static int[][] board = new int[4][4]; // array board
	static int[][] prevBoard = new int[4][4];
	static int[][] nextBoard = new int [4][4];

	static int validMoves = 0;
	static boolean isNotFull;
	static boolean confirmationYN;
	static boolean quit;

	public static void main(String[] args) {

		/* RUNTIME VARIABLES */

		// Scanner for input, boolean for running game

		System.out.println("Game Start");

		doRandom();
		doRandom();

		printArr();
		// INTIALIZES PREV BOAR DTO BOARD //
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				prevBoard[i][j] = board[i][j];
			}
		}

		Scanner sc = new Scanner(System.in);

		String input;

		while ((quit != true)) {

			input = sc.nextLine();

			// IF YOU PRESS W GO TO

			if (input.equals("s")) {
				System.out.println("s");

				pressS();

			} else if (input.equals("a")) {
				System.out.println("a");
				pressA();

			} else if (input.equals("w")) {
				System.out.println("w");

				pressW();

			} else if (input.equals("d")) {
				System.out.println("d");

				pressD();

				// quit if input == q

			} else if (input.equals("q")) {
				System.out.println("q");

				System.out.println("Quit");
				confirmation();

				if (confirmationYN) {

					quit = true;

				}
				printArr();

			} else if (input.equals("r")) {

				confirmation();

				if (confirmationYN) {

					for (int row = 0; row < board.length; ++row) {

						for (int col = 0; col < board[row].length; ++col) {
							board[row][col] = 0;

						}
					}
					System.out.println("Restart");

				}

				printArr();

				// RESTART - NEW GAME

			} else {
				System.out.println("invalid command");
			}
		}

		/*
		 * if (java.util.Arrays.deepEquals(board, prevBoard)) {
		 * System.out.println("equal");
		 * 
		 * } else { validMoves++; prevBoard = board;
		 * 
		 * }
		 * 
		 * }
		 * 
		 */
	}

	public static boolean isValid(int[][] arr1, int[][] arr2) {
		for (int i = 0; i < arr1.length; i++) {
			for (int j = 0; j < arr1[i].length; j++) {
				if (arr1[i][j] != arr2[i][j]) {
					validMoves += 1;
					copyBoard();

				}
			}

			return false;

		}

		return true;

	}
/*
 * 
 * 
 * private boolean checkLoss() {
        int[][] before = deepCopy(board);
        boolean leftChange = true;
        updateBoard(KeyEvent.VK_LEFT, false);
        if (Arrays.deepEquals(before, board)) leftChange = false;
        board = before;
        boolean upChange = true;
        updateBoard(KeyEvent.VK_UP, false);
        if (Arrays.deepEquals(before, board)) upChange = false;
        board = before;
        boolean rightChange = true;
        updateBoard(KeyEvent.VK_RIGHT, false);
        if (Arrays.deepEquals(before, board)) rightChange = false;
        board = before;
        boolean downChange = true;
        updateBoard(KeyEvent.VK_DOWN, false);
        if (Arrays.deepEquals(before, board)) downChange = false;
        board = before;
        if (leftChange || upChange || rightChange || downChange) return false;
        return true;
    }
 */
	public static void pressS() {

		// Bottom to top See Lab 3
		for (int col = 0; col < board.length; col++) {
			int count = 0;

			for (int row = board[col].length - 1; row >= 0; row--)

			{
				if (board[row][col] != 0) {
					board[board.length - 1 - count][col] = board[row][col];
					// empty the original tile position after tile is moved
					if (board.length - 1 - count != row) {
						board[row][col] = 0;
					}
					count++;
				}

			}

		}

		for (int col = 0; col < board.length; col++) {
			for (int row = board.length - 1; row > 0; row--) {
				if (board[row][col] == board[row - 1][col])
				// add the two tiles with the same value
				{
					board[row][col] += board[row - 1][col];
					board[row - 1][col] = 0;
					// update the score ONCE!

					break;

				}
			}
		}

		// after adding two tiles, repeat the same first for loop
		// in this method to move all the tiles to the bottom
		for (int col = 0; col < board.length; col++) {
			int count = 0;

			for (int row = board.length - 1; row >= 0; row--)

			{
				if (board[row][col] != 0) {
					board[board.length - 1 - count][col] = board[row][col];
					// empty the original tile position after tile is moved
					if (board.length - 1 - count != row) {
						board[row][col] = 0;
					}
					count++;
				}

			}

		}

		checkFull(); // Put Random number on board
		isValid(prevBoard, board);
		printArr();

	}

	public static void pressD() {
		for (int row = 0; row < board.length; row++) {
			int count = 0;

			for (int col = board.length - 1; col >= 0; col--)

			{
				if (board[row][col] != 0) {
					board[row][board.length - 1 - count] = board[row][col];
					// empty the original tile position after tile is moved
					if (board.length - 1 - count != col) {
						board[row][col] = 0;
					}
					count++;
				}

			}

		}

		for (int row = 0; row < board.length; row++) {
			for (int col = board.length - 1; col > 0; col--) {
				if (board[row][col] == board[row][col - 1])
				// add the two tiles with the same value
				{
					board[row][col] += board[row][col - 1];
					board[row][col - 1] = 0;
					// update the score ONCE!
					int sum = board[row][col];
					// this.score += sum;

					break;

				}
			}
		}

		// after adding two tiles, repeat the same first for loop
		// in this method to move all the tiles to the right side
		for (int row = 0; row < board.length; row++) {
			int count = 0;

			for (int col = board.length - 1; col >= 0; col--)

			{
				if (board[row][col] != 0) {
					board[row][board.length - 1 - count] = board[row][col];
					if (board.length - 1 - count != col) {
						board[row][col] = 0;
					}
					count++;
				}

			}

		}

		checkFull(); // Put Random number on board
		isValid(prevBoard, board);

		printArr();

	}

	public static void pressW() {

		// use count tom ove the tiles to the top one by one
		for (int col = 0; col < board.length; col++) {
			int count = 0;
			for (int row = 0; row < board.length; row++) {
				if (board[row][col] != 0) {
					board[0 + count][col] = board[row][col];
					// empty the original tile position after tile is moved
					if (0 + count != row) {
						board[row][col] = 0;
					}
					count++;
				}
			}
		}
		for (int col = 0; col < board.length; col++) {
			for (int row = 0; row < board.length - 1; row++) {
				if (board[row][col] == board[row + 1][col]) {
					// add the two tiles with the same value
					board[row][col] += board[row + 1][col];
					board[row + 1][col] = 0;

					break;
				}
			}
		}
		for (int col = 0; col < board.length; col++) {
			int count = 0;
			for (int row = 0; row < board.length; row++) {
				if (board[row][col] != 0) {
					board[0 + count][col] = board[row][col];
					// empty the original tile position after tile is moved
					if (0 + count != row) {
						board[row][col] = 0;
					}
					count++;
				}
			}
		}

		checkFull();
		isValid(prevBoard, board);

		printArr();
	}

	// possibly fixed
	public static void pressA() {

		for (int row = 0; row < board.length; row++) {
			int count = 0;

			for (int col = 0; col < board[row].length; col++) {

				if (board[row][col] != 0) {
					board[row][0 + count] = board[row][col];

					if (0 + count != col) {
						board[row][col] = 0;
					}
					count++;
				}
			}

		}
		for (int row = 0; row < board.length; row++) {
			for (int col = 0; col < board[row].length - 1; col++) {
				if (board[row][col] == board[row][col + 1])
				// add the two tiles with the same value
				{
					board[row][col] += board[row][col + 1];
					board[row][col + 1] = 0;
					// update the score ONCE!
					// int sum=board[row][col];
					break;

				}
			}
		}

		// after adding two tiles, repeat the first for loop
		// in this method to move all the tiles to the left side
		for (int row = 0; row < board.length; row++) {
			int count = 0;
			for (int col = 0; col < board.length; col++)

			{
				if (board[row][col] != 0) {
					board[row][0 + count] = board[row][col];
					// Empty the original tile position once tile is moved
					if (0 + count != col) {
						board[row][col] = 0;
					}
					count++;
				}
			}

		}

		checkFull();
		isValid(prevBoard, board);

		printArr();
	}

	public static void doRandom() {

		// Create random x and y to select

		Random random = new Random();

		int min = 0;

		int max = 3;

		int index = random.nextInt(4);

		int arrIndex = random.nextInt(4);

		int randomNum = new Random().nextDouble() < 0.8 ? 2 : 4; // Random number with 80 chance 2 rest 4

		// Check if board is full
		// If the random index already selected is full try again

		if (board[arrIndex][index] != 0) {

			// System.out.println("Trying again");

			doRandom();

		} else {

			// Else Assign Value to random index

			board[arrIndex][index] = randomNum;

		}

	}

	/* Print the Board */

	public static void printArr() {

		for (int[] row : board) {

			for (int item : row) {

				System.out.printf("%4d", item);

			}

			System.out.println();

		}

		System.out.println();
		System.out.println(validMoves);

	}

	public static boolean checkFull() {
		//IS BOARD IS FULL 
		for (int row = 0; row < board.length; row++) {
			for (int col = 0; col < board[row].length; col++) {
				if (board[row][col] == 0) {
					doRandom();
					return true; // BOARD IS NOT NOT FULL

				}
			}

		}
		
		// IF YOU CANNOT MAKE ANY MORE MATCHES
		System.out.print("Game Over");
		System.out.println("Valid Moves:" + validMoves);
		quit = true;
		return false;

	}

	public static void confirmation() {
		Scanner scanCon = new Scanner(System.in);

		System.out.println("Are you sure you wanna restart? input y/n");
		String confirmation = scanCon.nextLine();

		if (confirmation.equals("y")) {
			confirmationYN = true;
		} else if (confirmation.equals("n")) {
			confirmationYN = false;
		} else {
			System.out.println("Try again");

			return;

		}

	}

	public static void copyBoard() {

		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				prevBoard[i][j] = board[i][j];
			}
		}

	}

}
